import numpy as np

from scipy.linalg import eig

d = 2

# start with a density matrix
density_matrix = np.arange(d**2).reshape(d,d)
# row vectorisation (default in C)
dm_vec = density_matrix.reshape(d**2)
# column vectorisation (default in Fortran)
dm_colvec = density_matrix.reshape(d**2,order='F')

# random superoperator
superoperator = np.arange(d**4).reshape(d,d,d,d)

# no vectorisation here,
dm_final = np.einsum('ijkl,kl->ij',superoperator,density_matrix)
print(dm_final)

# ok now do vectorisation:
# superoperator as in tempo (row vectorisation)
liouville_superoperator = superoperator.reshape(d**2,d**2)
# were tempo to be written in a column vectorisation language
liouville_superoperator_colvec = superoperator.reshape(d**2,d**2,order='F')


dm_final_liouville = np.dot(liouville_superoperator,dm_vec)
dm_final_colvec_liouville = np.dot(liouville_superoperator_colvec,dm_colvec)

print(dm_final_liouville)
print(dm_final_colvec_liouville)

density_matrix_recovered = dm_final_colvec_liouville.reshape(d,d,order='F')
print(density_matrix_recovered)
# success
# assuming superoperator is generated by a row vectorisation
choi_matrix = np.swapaxes(superoperator,0,2)
choi_matrix = np.swapaxes(choi_matrix,2,3)
choi_matrix = np.swapaxes(choi_matrix,1,3)

print('choi_matrix')
print(choi_matrix)

# print(np.einsum('ijkl,li->kj',choi_matrix,density_matrix))
print(np.einsum('kilj,kl->ij',choi_matrix,density_matrix)) # correct
print(np.einsum('ijkl,ik->jl',choi_matrix,density_matrix))

choi_as_matrix = np.reshape(choi_matrix,(d**2,d**2))

eigvals,eigvec = eig(choi_as_matrix)

kraus_operators = np.zeros((d**2,d,d))
for i in range(d**2):
    # see scipy documentation, right eigenvector is the column vector
    kraus_operators[i] = eigvec[:,i].reshape(d,d)

print(eigvals)
print(eigvec)